{"ast":null,"code":"var _jsxFileName = \"/home/cristian/Documentos/7mo/lenguajes_programacion/Videoconferencia-app/client/src/components/PdfViewer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\n// Worker setup for pdfjs-dist\n// Using CDN to ensure correct version and headers. Use .mjs for module support in v5+\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\npdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.mjs`;\nconst PdfViewer = ({\n  fileUrl,\n  pageNumber,\n  scale = 1.0,\n  onPageLoadSuccess,\n  onPageLoadError,\n  whiteboardData,\n  onDraw,\n  canDraw,\n  containerWidth\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const whiteboardRef = useRef(null);\n  const [renderTask, setRenderTask] = useState(null);\n  const [drawing, setDrawing] = useState(false);\n  const [lastPos, setLastPos] = useState(null);\n  const [viewport, setViewport] = useState(null);\n\n  // Load and render PDF page\n  useEffect(() => {\n    let active = true;\n    const renderPage = async () => {\n      if (!fileUrl) return;\n      try {\n        const loadingTask = pdfjsLib.getDocument(fileUrl);\n        const pdf = await loadingTask.promise;\n        if (!active) return;\n        const page = await pdf.getPage(pageNumber);\n        if (!active) return;\n\n        // Calculate scale to fit container width\n        const originalViewport = page.getViewport({\n          scale: 1\n        });\n        const desiredScale = containerWidth ? containerWidth / originalViewport.width : 1;\n        const newViewport = page.getViewport({\n          scale: desiredScale\n        });\n        setViewport(newViewport);\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        canvas.height = newViewport.height;\n        canvas.width = newViewport.width;\n\n        // Resize whiteboard canvas to match\n        if (whiteboardRef.current) {\n          whiteboardRef.current.height = newViewport.height;\n          whiteboardRef.current.width = newViewport.width;\n        }\n        const renderContext = {\n          canvasContext: context,\n          viewport: newViewport\n        };\n        if (renderTask) {\n          await renderTask.promise; // Wait for previous render to cancel or finish ? \n          // Actually pdfjs cancels automatically if you call cancel()\n          // but here we just store the task.\n        }\n        const task = page.render(renderContext);\n        setRenderTask(task);\n        await task.promise;\n        if (onPageLoadSuccess) onPageLoadSuccess(pdf.numPages);\n      } catch (error) {\n        if (error.name === 'RenderingCancelledException') {\n          // Check for cancellation\n        } else {\n          console.error('Error rendering PDF:', error);\n          if (onPageLoadError) onPageLoadError(error);\n        }\n      }\n    };\n    renderPage();\n    return () => {\n      active = false;\n      if (renderTask) {\n        // renderTask.cancel(); // causing issues sometimes\n      }\n    };\n  }, [fileUrl, pageNumber, containerWidth]);\n\n  // Render Whiteboard Lines\n  useEffect(() => {\n    if (!whiteboardRef.current || !viewport || !whiteboardData) return;\n    const canvas = whiteboardRef.current;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before redraw\n\n    // Draw all lines\n    whiteboardData.lines.forEach(line => {\n      if (line.points.length < 2) return;\n      ctx.beginPath();\n      ctx.strokeStyle = line.color;\n      ctx.lineWidth = line.width; // We might need to scale width relative to viewport\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n\n      // Start\n      // Points are stored ideally as normalized [0-1] coordinates relative to PDF size\n      // But implementation simplicity: stored as raw relative to some standard, OR we normalize now.\n      // Let's assume points are normalized [x, y, x, y...] (0-1) to handle resizing responsiveness\n\n      // If we store raw pixels, resizing breaks it.\n      // PROPOSAL: Store normalized coordinates [0-1].\n\n      const w = canvas.width;\n      const h = canvas.height;\n      ctx.moveTo(line.points[0] * w, line.points[1] * h);\n      for (let i = 2; i < line.points.length; i += 2) {\n        ctx.lineTo(line.points[i] * w, line.points[i + 1] * h);\n      }\n      ctx.stroke();\n    });\n  }, [whiteboardData, viewport]);\n\n  // Drawing Handlers\n  const getCoords = e => {\n    const canvas = whiteboardRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (e.clientX || e.touches[0].clientX) - rect.left;\n    const y = (e.clientY || e.touches[0].clientY) - rect.top;\n\n    // Normalize relative to visual size (rect)\n    return {\n      x: x / rect.width,\n      y: y / rect.height\n    };\n  };\n  const startDrawing = e => {\n    if (!canDraw) return;\n    setDrawing(true);\n    const {\n      x,\n      y\n    } = getCoords(e);\n    setLastPos({\n      x,\n      y\n    });\n  };\n  const draw = e => {\n    if (!drawing || !canDraw || !lastPos) return;\n    e.preventDefault(); // Prevent scroll on touch\n\n    const currentPos = getCoords(e);\n\n    // Emit single segment or build a line? \n    // Emitting segments (line from A to B) is better for real-time.\n    // BUT we need to associate them to a single \"stroke\" if we want undo later.\n    // For now, simpler: Emit 'stroke-segment' or just update local state and emit full line on mouseUp?\n    // Real-time collaboration needssegments.\n\n    // Strategy: We draw locally immediately. We verify 'line' in backend is full array.\n    // Let's emit the WHOLE line? No, too big.\n    // Let's emit a segment. 'whiteboard-draw' event will take a full line object?\n    // Actually simpler for MVP: Emit the single small line segment as a \"Line\" object.\n\n    const newLine = {\n      points: [lastPos.x, lastPos.y, currentPos.x, currentPos.y],\n      color: '#ff0000',\n      // Default red\n      width: 3,\n      tool: 'pen'\n    };\n    if (onDraw) onDraw(newLine);\n    setLastPos(currentPos);\n  };\n  const stopDrawing = () => {\n    setDrawing(false);\n    setLastPos(null);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        display: 'block',\n        width: '100%'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: whiteboardRef,\n      style: {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        cursor: canDraw ? 'crosshair' : 'default',\n        touchAction: 'none'\n      },\n      onMouseDown: startDrawing,\n      onMouseMove: draw,\n      onMouseUp: stopDrawing,\n      onMouseLeave: stopDrawing,\n      onTouchStart: startDrawing,\n      onTouchMove: draw,\n      onTouchEnd: stopDrawing\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 192,\n    columnNumber: 9\n  }, this);\n};\n_s(PdfViewer, \"Jd/ZEPXmiT8fq9MsY+X2Fbq1icE=\");\n_c = PdfViewer;\nexport default PdfViewer;\nvar _c;\n$RefreshReg$(_c, \"PdfViewer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","pdfjsLib","jsxDEV","_jsxDEV","GlobalWorkerOptions","workerSrc","version","PdfViewer","fileUrl","pageNumber","scale","onPageLoadSuccess","onPageLoadError","whiteboardData","onDraw","canDraw","containerWidth","_s","canvasRef","whiteboardRef","renderTask","setRenderTask","drawing","setDrawing","lastPos","setLastPos","viewport","setViewport","active","renderPage","loadingTask","getDocument","pdf","promise","page","getPage","originalViewport","getViewport","desiredScale","width","newViewport","canvas","current","context","getContext","height","renderContext","canvasContext","task","render","numPages","error","name","console","ctx","clearRect","lines","forEach","line","points","length","beginPath","strokeStyle","color","lineWidth","lineCap","lineJoin","w","h","moveTo","i","lineTo","stroke","getCoords","e","rect","getBoundingClientRect","x","clientX","touches","left","y","clientY","top","startDrawing","draw","preventDefault","currentPos","newLine","tool","stopDrawing","style","position","children","ref","display","fileName","_jsxFileName","lineNumber","columnNumber","cursor","touchAction","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onTouchStart","onTouchMove","onTouchEnd","_c","$RefreshReg$"],"sources":["/home/cristian/Documentos/7mo/lenguajes_programacion/Videoconferencia-app/client/src/components/PdfViewer.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\n// Worker setup for pdfjs-dist\n// Using CDN to ensure correct version and headers. Use .mjs for module support in v5+\npdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.mjs`;\n\nconst PdfViewer = ({\n    fileUrl,\n    pageNumber,\n    scale = 1.0,\n    onPageLoadSuccess,\n    onPageLoadError,\n    whiteboardData,\n    onDraw,\n    canDraw,\n    containerWidth\n}) => {\n    const canvasRef = useRef(null);\n    const whiteboardRef = useRef(null);\n    const [renderTask, setRenderTask] = useState(null);\n    const [drawing, setDrawing] = useState(false);\n    const [lastPos, setLastPos] = useState(null);\n    const [viewport, setViewport] = useState(null);\n\n    // Load and render PDF page\n    useEffect(() => {\n        let active = true;\n\n        const renderPage = async () => {\n            if (!fileUrl) return;\n\n            try {\n                const loadingTask = pdfjsLib.getDocument(fileUrl);\n                const pdf = await loadingTask.promise;\n\n                if (!active) return;\n\n                const page = await pdf.getPage(pageNumber);\n\n                if (!active) return;\n\n                // Calculate scale to fit container width\n                const originalViewport = page.getViewport({ scale: 1 });\n                const desiredScale = containerWidth ? (containerWidth / originalViewport.width) : 1;\n                const newViewport = page.getViewport({ scale: desiredScale });\n                setViewport(newViewport);\n\n                const canvas = canvasRef.current;\n                const context = canvas.getContext('2d');\n                canvas.height = newViewport.height;\n                canvas.width = newViewport.width;\n\n                // Resize whiteboard canvas to match\n                if (whiteboardRef.current) {\n                    whiteboardRef.current.height = newViewport.height;\n                    whiteboardRef.current.width = newViewport.width;\n                }\n\n                const renderContext = {\n                    canvasContext: context,\n                    viewport: newViewport,\n                };\n\n                if (renderTask) {\n                    await renderTask.promise; // Wait for previous render to cancel or finish ? \n                    // Actually pdfjs cancels automatically if you call cancel()\n                    // but here we just store the task.\n                }\n\n                const task = page.render(renderContext);\n                setRenderTask(task);\n\n                await task.promise;\n                if (onPageLoadSuccess) onPageLoadSuccess(pdf.numPages);\n\n            } catch (error) {\n                if (error.name === 'RenderingCancelledException') {\n                    // Check for cancellation\n                } else {\n                    console.error('Error rendering PDF:', error);\n                    if (onPageLoadError) onPageLoadError(error);\n                }\n            }\n        };\n\n        renderPage();\n\n        return () => {\n            active = false;\n            if (renderTask) {\n                // renderTask.cancel(); // causing issues sometimes\n            }\n        };\n    }, [fileUrl, pageNumber, containerWidth]);\n\n    // Render Whiteboard Lines\n    useEffect(() => {\n        if (!whiteboardRef.current || !viewport || !whiteboardData) return;\n\n        const canvas = whiteboardRef.current;\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before redraw\n\n        // Draw all lines\n        whiteboardData.lines.forEach(line => {\n            if (line.points.length < 2) return;\n\n            ctx.beginPath();\n            ctx.strokeStyle = line.color;\n            ctx.lineWidth = line.width; // We might need to scale width relative to viewport\n            ctx.lineCap = 'round';\n            ctx.lineJoin = 'round';\n\n            // Start\n            // Points are stored ideally as normalized [0-1] coordinates relative to PDF size\n            // But implementation simplicity: stored as raw relative to some standard, OR we normalize now.\n            // Let's assume points are normalized [x, y, x, y...] (0-1) to handle resizing responsiveness\n\n            // If we store raw pixels, resizing breaks it.\n            // PROPOSAL: Store normalized coordinates [0-1].\n\n            const w = canvas.width;\n            const h = canvas.height;\n\n            ctx.moveTo(line.points[0] * w, line.points[1] * h);\n\n            for (let i = 2; i < line.points.length; i += 2) {\n                ctx.lineTo(line.points[i] * w, line.points[i + 1] * h);\n            }\n            ctx.stroke();\n        });\n\n    }, [whiteboardData, viewport]);\n\n\n    // Drawing Handlers\n    const getCoords = (e) => {\n        const canvas = whiteboardRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const x = (e.clientX || e.touches[0].clientX) - rect.left;\n        const y = (e.clientY || e.touches[0].clientY) - rect.top;\n\n        // Normalize relative to visual size (rect)\n        return {\n            x: x / rect.width,\n            y: y / rect.height\n        };\n    }\n\n    const startDrawing = (e) => {\n        if (!canDraw) return;\n        setDrawing(true);\n        const { x, y } = getCoords(e);\n        setLastPos({ x, y });\n    };\n\n    const draw = (e) => {\n        if (!drawing || !canDraw || !lastPos) return;\n        e.preventDefault(); // Prevent scroll on touch\n\n        const currentPos = getCoords(e);\n\n        // Emit single segment or build a line? \n        // Emitting segments (line from A to B) is better for real-time.\n        // BUT we need to associate them to a single \"stroke\" if we want undo later.\n        // For now, simpler: Emit 'stroke-segment' or just update local state and emit full line on mouseUp?\n        // Real-time collaboration needssegments.\n\n        // Strategy: We draw locally immediately. We verify 'line' in backend is full array.\n        // Let's emit the WHOLE line? No, too big.\n        // Let's emit a segment. 'whiteboard-draw' event will take a full line object?\n        // Actually simpler for MVP: Emit the single small line segment as a \"Line\" object.\n\n        const newLine = {\n            points: [lastPos.x, lastPos.y, currentPos.x, currentPos.y],\n            color: '#ff0000', // Default red\n            width: 3,\n            tool: 'pen'\n        };\n\n        if (onDraw) onDraw(newLine);\n\n        setLastPos(currentPos);\n    };\n\n    const stopDrawing = () => {\n        setDrawing(false);\n        setLastPos(null);\n    };\n\n    return (\n        <div style={{ position: 'relative', width: '100%', height: '100%' }}>\n            <canvas\n                ref={canvasRef}\n                style={{ display: 'block', width: '100%' }}\n            />\n            <canvas\n                ref={whiteboardRef}\n                style={{\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    cursor: canDraw ? 'crosshair' : 'default',\n                    touchAction: 'none'\n                }}\n                onMouseDown={startDrawing}\n                onMouseMove={draw}\n                onMouseUp={stopDrawing}\n                onMouseLeave={stopDrawing}\n                onTouchStart={startDrawing}\n                onTouchMove={draw}\n                onTouchEnd={stopDrawing}\n            />\n        </div>\n    );\n};\n\nexport default PdfViewer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}